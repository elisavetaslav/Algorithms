# Task
Однажды Константин, поучаствовав в очередной, уже 13-й по счету международной олимпиаде, возвращался на поезде домой. Он как всегда сидел и размышлял о смысле жизни, попутно решая задачи по программированию. Через некоторое время Константин задремал, но вот беда, для того, чтобы проснуться, он должен решить всплывшую у него в голове задачу, не дающую ему покоя!
В этот раз Константину приснилось дерево, изначально состоящее всего из одной вершины с номером 1. В поставленной им задаче к дереву постепенно добавлялись новые вершины. В *i*-ю секунду в дерево добавлялась вершина с номером *i + 1*, которая подвешивалась в качестве сына к вершине *p_i*, а на ребре между вершинами *i + 1* и *p_i*
записывалась буква *c_i*.
Каждому пути из корня дерева до вершины *v* соответствует некоторая строка, получающаяся путем выписывания символов, записанных на ребрах текущего пути в порядке следования от корня к вершине *v*. Перед Константином стояла нелегкая на первый взгляд задача — после каждого добавления новой вершины посчитать количество уникальных строк, начинающихся в корне дерева (вершине с номером 1), и заканчивающихся в какой-либо другой вершине.
В своем сне Константин вовсе не гений, поэтому решить эту задачу сам он не в силах. Помогите Константину решить задачу и тем самым проснуться.

### Формат ввода
В первой строке записано число *n* — количество запросов на добавление новой вершины в дерево **(1 ≤ n ≤ 3*10^5)**.
В следующих *n* строках описаны запросы добавления вершин.
*i*-й запрос описывается параметрами *p_i(1 ≤ p_i ≤ i*) и *c_i* , которые означают, что добавленная вершина с номером *i + 1* подвешивается к вершине с номером *p_i* в качестве потомка, а на полученном ребре записывается символ c *i* — строчная буква латинского алфавита.

### Формат вывода
Выведите *n* строк. В *i* -й строке выведите ответ на задачу Константина после добавления *(i + 1)*-й вершины.